/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */
/** Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered */
export var CollectionStatus;
(function (CollectionStatus) {
    CollectionStatus["Green"] = "green";
    CollectionStatus["Yellow"] = "yellow";
    CollectionStatus["Red"] = "red";
})(CollectionStatus || (CollectionStatus = {}));
/** Type of internal tags, build from payload Distance function types used to compare vectors */
export var Distance;
(function (Distance) {
    Distance["Cosine"] = "Cosine";
    Distance["Euclid"] = "Euclid";
    Distance["Dot"] = "Dot";
})(Distance || (Distance = {}));
export var ScalarType;
(function (ScalarType) {
    ScalarType["Int8"] = "int8";
})(ScalarType || (ScalarType = {}));
/** All possible names of payload types */
export var PayloadSchemaType;
(function (PayloadSchemaType) {
    PayloadSchemaType["Keyword"] = "keyword";
    PayloadSchemaType["Integer"] = "integer";
    PayloadSchemaType["Float"] = "float";
    PayloadSchemaType["Geo"] = "geo";
    PayloadSchemaType["Text"] = "text";
})(PayloadSchemaType || (PayloadSchemaType = {}));
export var TextIndexType;
(function (TextIndexType) {
    TextIndexType["Text"] = "text";
})(TextIndexType || (TextIndexType = {}));
export var TokenizerType;
(function (TokenizerType) {
    TokenizerType["Prefix"] = "prefix";
    TokenizerType["Whitespace"] = "whitespace";
    TokenizerType["Word"] = "word";
})(TokenizerType || (TokenizerType = {}));
/** `Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual. */
export var UpdateStatus;
(function (UpdateStatus) {
    UpdateStatus["Acknowledged"] = "acknowledged";
    UpdateStatus["Completed"] = "completed";
})(UpdateStatus || (UpdateStatus = {}));
/** Role of the peer in the consensus */
export var StateRole;
(function (StateRole) {
    StateRole["Follower"] = "Follower";
    StateRole["Candidate"] = "Candidate";
    StateRole["Leader"] = "Leader";
    StateRole["PreCandidate"] = "PreCandidate";
})(StateRole || (StateRole = {}));
/** State of the single shard within a replica set. */
export var ReplicaState;
(function (ReplicaState) {
    ReplicaState["Active"] = "Active";
    ReplicaState["Dead"] = "Dead";
    ReplicaState["Partial"] = "Partial";
    ReplicaState["Initializing"] = "Initializing";
    ReplicaState["Listener"] = "Listener";
})(ReplicaState || (ReplicaState = {}));
/** Type of segment */
export var SegmentType;
(function (SegmentType) {
    SegmentType["Plain"] = "plain";
    SegmentType["Indexed"] = "indexed";
    SegmentType["Special"] = "special";
})(SegmentType || (SegmentType = {}));
/** Defines source of truth for snapshot recovery `Snapshot` means - prefer snapshot data over the current state `Replica` means - prefer existing data over the snapshot */
export var SnapshotPriority;
(function (SnapshotPriority) {
    SnapshotPriority["Snapshot"] = "snapshot";
    SnapshotPriority["Replica"] = "replica";
})(SnapshotPriority || (SnapshotPriority = {}));
/**
 * Defines write ordering guarantees for collection operations
 *
 * * `weak` - write operations may be reordered, works faster, default
 *
 * * `medium` - write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
 *
 * * `strong` - Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
 */
export var WriteOrdering;
(function (WriteOrdering) {
    WriteOrdering["Weak"] = "weak";
    WriteOrdering["Medium"] = "medium";
    WriteOrdering["Strong"] = "strong";
})(WriteOrdering || (WriteOrdering = {}));
/**
 * * `majority` - send N/2+1 random request and return points, which present on all of them
 *
 * * `quorum` - send requests to all nodes and return points which present on majority of nodes
 *
 * * `all` - send requests to all nodes and return points which present on all nodes
 */
export var ReadConsistencyType;
(function (ReadConsistencyType) {
    ReadConsistencyType["Majority"] = "majority";
    ReadConsistencyType["Quorum"] = "quorum";
    ReadConsistencyType["All"] = "all";
})(ReadConsistencyType || (ReadConsistencyType = {}));
export var ContentType;
(function (ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType || (ContentType = {}));
export class HttpClient {
    baseUrl = '{protocol}://{hostname}:{port}';
    securityData = null;
    securityWorker;
    abortControllers = new Map();
    customFetch = (...fetchParams) => fetch(...fetchParams);
    baseApiParams = {
        credentials: 'same-origin',
        headers: {},
        redirect: 'follow',
        referrerPolicy: 'no-referrer',
    };
    constructor(apiConfig = {}) {
        Object.assign(this, apiConfig);
    }
    setSecurityData = (data) => {
        this.securityData = data;
    };
    encodeQueryParam(key, value) {
        const encodedKey = encodeURIComponent(key);
        return `${encodedKey}=${encodeURIComponent(typeof value === 'number' ? value : `${value}`)}`;
    }
    addQueryParam(query, key) {
        return this.encodeQueryParam(key, query[key]);
    }
    addArrayQueryParam(query, key) {
        const value = query[key];
        return value.map((v) => this.encodeQueryParam(key, v)).join('&');
    }
    toQueryString(rawQuery) {
        const query = rawQuery || {};
        const keys = Object.keys(query).filter(key => 'undefined' !== typeof query[key]);
        return keys
            .map(key => Array.isArray(query[key])
            ? this.addArrayQueryParam(query, key)
            : this.addQueryParam(query, key))
            .join('&');
    }
    addQueryParams(rawQuery) {
        const queryString = this.toQueryString(rawQuery);
        return queryString ? `?${queryString}` : '';
    }
    contentFormatters = {
        [ContentType.Json]: (input) => input !== null && (typeof input === 'object' || typeof input === 'string')
            ? JSON.stringify(input)
            : input,
        [ContentType.Text]: (input) => input !== null && typeof input !== 'string' ? JSON.stringify(input) : input,
        [ContentType.FormData]: (input) => Object.keys(input || {}).reduce((formData, key) => {
            const property = input[key];
            formData.append(key, property instanceof Blob
                ? property
                : typeof property === 'object' && property !== null
                    ? JSON.stringify(property)
                    : `${property}`);
            return formData;
        }, new FormData()),
        [ContentType.UrlEncoded]: (input) => this.toQueryString(input),
    };
    mergeRequestParams(params1, params2) {
        return {
            ...this.baseApiParams,
            ...params1,
            ...(params2 || {}),
            headers: {
                ...(this.baseApiParams.headers || {}),
                ...(params1.headers || {}),
                ...((params2 && params2.headers) || {}),
            },
        };
    }
    createAbortSignal = (cancelToken) => {
        if (this.abortControllers.has(cancelToken)) {
            const abortController = this.abortControllers.get(cancelToken);
            if (abortController) {
                return abortController.signal;
            }
            return void 0;
        }
        const abortController = new AbortController();
        this.abortControllers.set(cancelToken, abortController);
        return abortController.signal;
    };
    abortRequest = (cancelToken) => {
        const abortController = this.abortControllers.get(cancelToken);
        if (abortController) {
            abortController.abort();
            this.abortControllers.delete(cancelToken);
        }
    };
    request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
        const secureParams = ((typeof secure === 'boolean' ? secure : this.baseApiParams.secure) &&
            this.securityWorker &&
            (await this.securityWorker(this.securityData))) ||
            {};
        const requestParams = this.mergeRequestParams(params, secureParams);
        const queryString = query && this.toQueryString(query);
        const payloadFormatter = this.contentFormatters[type || ContentType.Json];
        const responseFormat = format || requestParams.format;
        return this.customFetch(`${baseUrl || this.baseUrl || ''}${path}${queryString ? `?${queryString}` : ''}`, {
            ...requestParams,
            headers: {
                ...(requestParams.headers || {}),
                ...(type && type !== ContentType.FormData ? { 'Content-Type': type } : {}),
            },
            signal: cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal,
            body: typeof body === 'undefined' || body === null ? null : payloadFormatter(body),
        }).then(async (response) => {
            const r = response;
            r.data = null;
            r.error = null;
            const data = !responseFormat
                ? r
                : await response[responseFormat]()
                    .then(data => {
                    if (r.ok) {
                        r.data = data;
                    }
                    else {
                        r.error = data;
                    }
                    return r;
                })
                    .catch(e => {
                    r.error = e;
                    return r;
                });
            if (cancelToken) {
                this.abortControllers.delete(cancelToken);
            }
            if (!response.ok)
                throw data;
            return data;
        });
    };
}
/**
 * @title Qdrant API
 * @version master
 * @license Apache 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
 * @baseUrl {protocol}://{hostname}:{port}
 * @externalDocs https://qdrant.tech/documentation/
 * @contact <andrey@vasnetsov.com>
 *
 * API description for Qdrant vector search engine.
 *
 * This document describes CRUD and search operations on collections of points (vectors with payload).
 *
 * Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account.
 * ## Examples
 * This examples cover the most basic use-cases - collection creation and basic vector search.
 * ### Create collection
 * First - let's create a collection with dot-production metric.
 * ```
 * curl -X PUT 'http://localhost:6333/collections/test_collection' \
 *   -H 'Content-Type: application/json' \
 *   --data-raw '{
 *     "vectors": {
 *       "size": 4,
 *       "distance": "Dot"
 *     }
 *   }'
 *
 * ```
 * Expected response:
 * ```
 * {
 *     "result": true,
 *     "status": "ok",
 *     "time": 0.031095451
 * }
 * ```
 * We can ensure that collection was created:
 * ```
 * curl 'http://localhost:6333/collections/test_collection'
 * ```
 * Expected response:
 * ```
 * {
 *   "result": {
 *     "status": "green",
 *     "vectors_count": 0,
 *     "segments_count": 5,
 *     "disk_data_size": 0,
 *     "ram_data_size": 0,
 *     "config": {
 *       "params": {
 *         "vectors": {
 *           "size": 4,
 *           "distance": "Dot"
 *         }
 *       },
 *       "hnsw_config": {
 *         "m": 16,
 *         "ef_construct": 100,
 *         "full_scan_threshold": 10000
 *       },
 *       "optimizer_config": {
 *         "deleted_threshold": 0.2,
 *         "vacuum_min_vector_number": 1000,
 *         "max_segment_number": 5,
 *         "memmap_threshold": 50000,
 *         "indexing_threshold": 20000,
 *         "flush_interval_sec": 1
 *       },
 *       "wal_config": {
 *         "wal_capacity_mb": 32,
 *         "wal_segments_ahead": 0
 *       }
 *     }
 *   },
 *   "status": "ok",
 *   "time": 2.1199e-05
 * }
 * ```
 *
 * ### Add points
 * Let's now add vectors with some payload:
 * ```
 * curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \ -H 'Content-Type: application/json' \ --data-raw '{
 *   "points": [
 *     {"id": 1, "vector": [0.05, 0.61, 0.76, 0.74], "payload": {"city": "Berlin"}},
 *     {"id": 2, "vector": [0.19, 0.81, 0.75, 0.11], "payload": {"city": ["Berlin", "London"] }},
 *     {"id": 3, "vector": [0.36, 0.55, 0.47, 0.94], "payload": {"city": ["Berlin", "Moscow"] }},
 *     {"id": 4, "vector": [0.18, 0.01, 0.85, 0.80], "payload": {"city": ["London", "Moscow"] }},
 *     {"id": 5, "vector": [0.24, 0.18, 0.22, 0.44], "payload": {"count": [0]}},
 *     {"id": 6, "vector": [0.35, 0.08, 0.11, 0.44]}
 *   ]
 * }'
 * ```
 * Expected response:
 * ```
 * {
 *     "result": {
 *         "operation_id": 0,
 *         "status": "completed"
 *     },
 *     "status": "ok",
 *     "time": 0.000206061
 * }
 * ```
 * ### Search with filtering
 * Let's start with a basic request:
 * ```
 * curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \ -H 'Content-Type: application/json' \ --data-raw '{
 *     "vector": [0.2,0.1,0.9,0.7],
 *     "top": 3
 * }'
 * ```
 * Expected response:
 * ```
 * {
 *     "result": [
 *         { "id": 4, "score": 1.362, "payload": null, "version": 0 },
 *         { "id": 1, "score": 1.273, "payload": null, "version": 0 },
 *         { "id": 3, "score": 1.208, "payload": null, "version": 0 }
 *     ],
 *     "status": "ok",
 *     "time": 0.000055785
 * }
 * ```
 * But result is different if we add a filter:
 * ```
 * curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \ -H 'Content-Type: application/json' \ --data-raw '{
 *     "filter": {
 *         "should": [
 *             {
 *                 "key": "city",
 *                 "match": {
 *                     "value": "London"
 *                 }
 *             }
 *         ]
 *     },
 *     "vector": [0.2, 0.1, 0.9, 0.7],
 *     "top": 3
 * }'
 * ```
 * Expected response:
 * ```
 * {
 *     "result": [
 *         { "id": 4, "score": 1.362, "payload": null, "version": 0 },
 *         { "id": 2, "score": 0.871, "payload": null, "version": 0 }
 *     ],
 *     "status": "ok",
 *     "time": 0.000093972
 * }
 * ```
 */
export class Api extends HttpClient {
    telemetry = {
        /**
         * @description Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
         *
         * @tags service
         * @name Telemetry
         * @summary Collect telemetry data
         * @request GET:/telemetry
         */
        telemetry: (query, params = {}) => this.request({
            path: `/telemetry`,
            method: 'GET',
            query: query,
            format: 'json',
            ...params,
        }),
    };
    metrics = {
        /**
         * @description Collect metrics data including app info, collections info, cluster info and statistics
         *
         * @tags service
         * @name Metrics
         * @summary Collect Prometheus metrics data
         * @request GET:/metrics
         */
        metrics: (query, params = {}) => this.request({
            path: `/metrics`,
            method: 'GET',
            query: query,
            ...params,
        }),
    };
    locks = {
        /**
         * @description Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
         *
         * @tags service
         * @name PostLocks
         * @summary Set lock options
         * @request POST:/locks
         */
        postLocks: (data, params = {}) => this.request({
            path: `/locks`,
            method: 'POST',
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Get lock options. If write is locked, all write operations and collection creation are forbidden
         *
         * @tags service
         * @name GetLocks
         * @summary Get lock options
         * @request GET:/locks
         */
        getLocks: (params = {}) => this.request({
            path: `/locks`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
    };
    cluster = {
        /**
         * @description Get information about the current state and composition of the cluster
         *
         * @tags cluster
         * @name ClusterStatus
         * @summary Get cluster status info
         * @request GET:/cluster
         */
        clusterStatus: (params = {}) => this.request({
            path: `/cluster`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * No description
         *
         * @tags cluster
         * @name RecoverCurrentPeer
         * @summary Tries to recover current peer Raft state.
         * @request POST:/cluster/recover
         */
        recoverCurrentPeer: (params = {}) => this.request({
            path: `/cluster/recover`,
            method: 'POST',
            format: 'json',
            ...params,
        }),
        /**
         * @description Tries to remove peer from the cluster. Will return an error if peer has shards on it.
         *
         * @tags cluster
         * @name RemovePeer
         * @summary Remove peer from the cluster
         * @request DELETE:/cluster/peer/{peer_id}
         */
        removePeer: (peerId, query, params = {}) => this.request({
            path: `/cluster/peer/${peerId}`,
            method: 'DELETE',
            query: query,
            format: 'json',
            ...params,
        }),
    };
    collections = {
        /**
         * @description Get list name of all existing collections
         *
         * @tags collections
         * @name GetCollections
         * @summary List collections
         * @request GET:/collections
         */
        getCollections: (params = {}) => this.request({
            path: `/collections`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * @description Get detailed information about specified existing collection
         *
         * @tags collections
         * @name GetCollection
         * @summary Collection info
         * @request GET:/collections/{collection_name}
         */
        getCollection: (collectionName, params = {}) => this.request({
            path: `/collections/${collectionName}`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * @description Create new collection with given parameters
         *
         * @tags collections
         * @name CreateCollection
         * @summary Create collection
         * @request PUT:/collections/{collection_name}
         */
        createCollection: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}`,
            method: 'PUT',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Update parameters of the existing collection
         *
         * @tags collections
         * @name UpdateCollection
         * @summary Update collection parameters
         * @request PATCH:/collections/{collection_name}
         */
        updateCollection: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}`,
            method: 'PATCH',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Drop collection and all associated data
         *
         * @tags collections
         * @name DeleteCollection
         * @summary Delete collection
         * @request DELETE:/collections/{collection_name}
         */
        deleteCollection: (collectionName, query, params = {}) => this.request({
            path: `/collections/${collectionName}`,
            method: 'DELETE',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * No description
         *
         * @tags collections
         * @name UpdateAliases
         * @summary Update aliases of the collections
         * @request POST:/collections/aliases
         */
        updateAliases: (data, query, params = {}) => this.request({
            path: `/collections/aliases`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Create index for field in collection
         *
         * @tags collections
         * @name CreateFieldIndex
         * @summary Create index for field in collection
         * @request PUT:/collections/{collection_name}/index
         */
        createFieldIndex: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/index`,
            method: 'PUT',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Delete field index for collection
         *
         * @tags collections
         * @name DeleteFieldIndex
         * @summary Delete index for field in collection
         * @request DELETE:/collections/{collection_name}/index/{field_name}
         */
        deleteFieldIndex: (collectionName, fieldName, query, params = {}) => this.request({
            path: `/collections/${collectionName}/index/${fieldName}`,
            method: 'DELETE',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * @description Get cluster information for a collection
         *
         * @tags collections, cluster
         * @name CollectionClusterInfo
         * @summary Collection cluster info
         * @request GET:/collections/{collection_name}/cluster
         */
        collectionClusterInfo: (collectionName, params = {}) => this.request({
            path: `/collections/${collectionName}/cluster`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * No description
         *
         * @tags collections, cluster
         * @name UpdateCollectionCluster
         * @summary Update collection cluster setup
         * @request POST:/collections/{collection_name}/cluster
         */
        updateCollectionCluster: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/cluster`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Get list of all aliases for a collection
         *
         * @tags collections
         * @name GetCollectionAliases
         * @summary List aliases for collection
         * @request GET:/collections/{collection_name}/aliases
         */
        getCollectionAliases: (collectionName, params = {}) => this.request({
            path: `/collections/${collectionName}/aliases`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * @description Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         *
         * @tags snapshots, collections
         * @name RecoverFromUploadedSnapshot
         * @summary Recover from an uploaded snapshot
         * @request POST:/collections/{collection_name}/snapshots/upload
         */
        recoverFromUploadedSnapshot: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/snapshots/upload`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.FormData,
            format: 'json',
            ...params,
        }),
        /**
         * @description Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         *
         * @tags snapshots, collections
         * @name RecoverFromSnapshot
         * @summary Recover from a snapshot
         * @request PUT:/collections/{collection_name}/snapshots/recover
         */
        recoverFromSnapshot: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/snapshots/recover`,
            method: 'PUT',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Get list of snapshots for a collection
         *
         * @tags snapshots, collections
         * @name ListSnapshots
         * @summary List collection snapshots
         * @request GET:/collections/{collection_name}/snapshots
         */
        listSnapshots: (collectionName, params = {}) => this.request({
            path: `/collections/${collectionName}/snapshots`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * @description Create new snapshot for a collection
         *
         * @tags snapshots, collections
         * @name CreateSnapshot
         * @summary Create collection snapshot
         * @request POST:/collections/{collection_name}/snapshots
         */
        createSnapshot: (collectionName, query, params = {}) => this.request({
            path: `/collections/${collectionName}/snapshots`,
            method: 'POST',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * @description Delete snapshot for a collection
         *
         * @tags snapshots, collections
         * @name DeleteSnapshot
         * @summary Delete collection snapshot
         * @request DELETE:/collections/{collection_name}/snapshots/{snapshot_name}
         */
        deleteSnapshot: (collectionName, snapshotName, query, params = {}) => this.request({
            path: `/collections/${collectionName}/snapshots/${snapshotName}`,
            method: 'DELETE',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * @description Download specified snapshot from a collection as a file
         *
         * @tags snapshots, collections
         * @name GetSnapshot
         * @summary Download collection snapshot
         * @request GET:/collections/{collection_name}/snapshots/{snapshot_name}
         */
        getSnapshot: (collectionName, snapshotName, params = {}) => this.request({
            path: `/collections/${collectionName}/snapshots/${snapshotName}`,
            method: 'GET',
            ...params,
        }),
        /**
         * @description Retrieve full information of single point by id
         *
         * @tags points
         * @name GetPoint
         * @summary Get point
         * @request GET:/collections/{collection_name}/points/{id}
         */
        getPoint: (collectionName, id, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/${id}`,
            method: 'GET',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * @description Retrieve multiple points by specified IDs
         *
         * @tags points
         * @name GetPoints
         * @summary Get points
         * @request POST:/collections/{collection_name}/points
         */
        getPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
         *
         * @tags points
         * @name UpsertPoints
         * @summary Upsert points
         * @request PUT:/collections/{collection_name}/points
         */
        upsertPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points`,
            method: 'PUT',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Delete points
         *
         * @tags points
         * @name DeletePoints
         * @summary Delete points
         * @request POST:/collections/{collection_name}/points/delete
         */
        deletePoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/delete`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Set payload values for points
         *
         * @tags points
         * @name SetPayload
         * @summary Set payload
         * @request POST:/collections/{collection_name}/points/payload
         */
        setPayload: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/payload`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Replace full payload of points with new one
         *
         * @tags points
         * @name OverwritePayload
         * @summary Overwrite payload
         * @request PUT:/collections/{collection_name}/points/payload
         */
        overwritePayload: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/payload`,
            method: 'PUT',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Delete specified key payload for points
         *
         * @tags points
         * @name DeletePayload
         * @summary Delete payload
         * @request POST:/collections/{collection_name}/points/payload/delete
         */
        deletePayload: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/payload/delete`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Remove all payload for specified points
         *
         * @tags points
         * @name ClearPayload
         * @summary Clear payload
         * @request POST:/collections/{collection_name}/points/payload/clear
         */
        clearPayload: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/payload/clear`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Scroll request - paginate over all points which matches given filtering condition
         *
         * @tags points
         * @name ScrollPoints
         * @summary Scroll points
         * @request POST:/collections/{collection_name}/points/scroll
         */
        scrollPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/scroll`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Retrieve closest points based on vector similarity and given filtering conditions
         *
         * @tags points
         * @name SearchPoints
         * @summary Search points
         * @request POST:/collections/{collection_name}/points/search
         */
        searchPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/search`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Retrieve by batch the closest points based on vector similarity and given filtering conditions
         *
         * @tags points
         * @name SearchBatchPoints
         * @summary Search batch points
         * @request POST:/collections/{collection_name}/points/search/batch
         */
        searchBatchPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/search/batch`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         *
         * @tags points
         * @name RecommendPoints
         * @summary Recommend points
         * @request POST:/collections/{collection_name}/points/recommend
         */
        recommendPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/recommend`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         *
         * @tags points
         * @name RecommendBatchPoints
         * @summary Recommend batch points
         * @request POST:/collections/{collection_name}/points/recommend/batch
         */
        recommendBatchPoints: (collectionName, data, query, params = {}) => this.request({
            path: `/collections/${collectionName}/points/recommend/batch`,
            method: 'POST',
            query: query,
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
        /**
         * @description Count points which matches given filtering condition
         *
         * @tags points
         * @name CountPoints
         * @summary Count points
         * @request POST:/collections/{collection_name}/points/count
         */
        countPoints: (collectionName, data, params = {}) => this.request({
            path: `/collections/${collectionName}/points/count`,
            method: 'POST',
            body: data,
            type: ContentType.Json,
            format: 'json',
            ...params,
        }),
    };
    aliases = {
        /**
         * @description Get list of all existing collections aliases
         *
         * @tags collections
         * @name GetCollectionsAliases
         * @summary List collections aliases
         * @request GET:/aliases
         */
        getCollectionsAliases: (params = {}) => this.request({
            path: `/aliases`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
    };
    snapshots = {
        /**
         * @description Get list of snapshots of the whole storage
         *
         * @tags snapshots
         * @name ListFullSnapshots
         * @summary List of storage snapshots
         * @request GET:/snapshots
         */
        listFullSnapshots: (params = {}) => this.request({
            path: `/snapshots`,
            method: 'GET',
            format: 'json',
            ...params,
        }),
        /**
         * @description Create new snapshot of the whole storage
         *
         * @tags snapshots
         * @name CreateFullSnapshot
         * @summary Create storage snapshot
         * @request POST:/snapshots
         */
        createFullSnapshot: (query, params = {}) => this.request({
            path: `/snapshots`,
            method: 'POST',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * @description Delete snapshot of the whole storage
         *
         * @tags snapshots
         * @name DeleteFullSnapshot
         * @summary Delete storage snapshot
         * @request DELETE:/snapshots/{snapshot_name}
         */
        deleteFullSnapshot: (snapshotName, query, params = {}) => this.request({
            path: `/snapshots/${snapshotName}`,
            method: 'DELETE',
            query: query,
            format: 'json',
            ...params,
        }),
        /**
         * @description Download specified snapshot of the whole storage as a file
         *
         * @tags snapshots
         * @name GetFullSnapshot
         * @summary Download storage snapshot
         * @request GET:/snapshots/{snapshot_name}
         */
        getFullSnapshot: (snapshotName, params = {}) => this.request({
            path: `/snapshots/${snapshotName}`,
            method: 'GET',
            ...params,
        }),
    };
}
